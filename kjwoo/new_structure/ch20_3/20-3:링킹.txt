저장방식 지정자
    static

    thread_local

    extern

    mutable (이 녀석의 경우 저장 기간과 링크 방식에 영향을 주지는 않습니다.)

저장기간
자동 저장기간
여기에 해당하는 개체들은 {}안에 정의된 객체들로 코드블록을 빠져나가면 자동으로 소멸함.
static, extern, thread_local로 지정된 객체들 이외의 모든 지역객체들이 이 자동저장기간을 가짐
(흔히 말하는 지역변수)

static 저장 기간
static 저장 기간에 해당하는 개체들은 프로그램 시작시 할당되고 끝날때 소멸
static 객체들은 프로그램에서 유일하게 존재한다.
지역변수의 경우 만일 여러 쓰레드에서 같은 함수를 실행하면 지역변수의 복사본들이 여러군데 존재하지만
static객체는 이 경우에도 유일하게 존재함.

보통 함수 밖에 정의된 것이나 static 혹은 extern으로 정의된 객체들이 static저장기간을 갖는다.
static이 아니더라도 static 저장기간을 가질 수 있으니 주의

int a; // 전역변수 static저장기간
namespace ss{
    int b; //static 저장기간
}
extern int a; //static 저장기간
int func(){
    static int x; //static 저장기간. 
}

쓰레드 저장기간
쓰레드 저장기간에 해당하는 객체들은 쓰레드 시작시 할당되고, 쓰레드 종료시 소멸
thread_local로 선언된 객체들이 쓰레드 저장기간을 갖는다.
thread_local 객체들은 각 쓰레드들이 해당객체들의 복사본을 갖게됨. 
마치 전역변수처럼 정의돼있지만 실제로는 쓰레드에 하나씩 복사본을 갖게되고 
그 쓰레드 안에서 전역변수인 것 처럼 참조가됨.

동적 저장기간.
동적할당함수를 통해 할당되고 해제되는 객체들
new, delete로 정의되는 객체들.

링크방식
저장방식은 객체들에게만 해당되지만 링크방식은 객체,함수,클래스,템플릿,이름공간 등등 지칭이름들에 적용됨.

1.No linkage 방식
{}안에 정의된 이름들이 이 경우에 해당.
extern으로 지정되지 않는 이상 링크 방식이 지정되지않는 개체들의 경우 같은 스코프 내에서만 참조가 가능

2.Internal Linkage 방식
static으로 정의된 함수,변수,템플릿함수,템플릿변수들이 내부링크방식에 해당.
내부링크방식으로 정의된 것들은 같은 TU내에서만 참조가 가능. 그외 익명의 이름공간에 정의된 함수나
변수들 모두 내부링크방식
namespace {
int a;  // <- 내부 링크 방식
}
static int a;  // 이와 동일한 의미

3. external Linkage
외부링크방식으로 정의된 개체들은 다른TU에서도 참조 가능합니다.
참고로 외부 링크방식으로 정의된 개체들에 언어링크방식을 정의 할수도있어서
다른 언어사이에서 함수를 공유하는 것이 가능해집니다.
블록 스코프 안에 정의된 변수를 외부링크방식으로 선언하고싶다면 extern키워드를 사용하면된다.

extern "C" int func();  // C 및 C++ 에서 사용할 수 있는 함수.

// C++ 에서만 사용할 수 있는 함수. 기본적으로 C++ 의 모든 함수들에 extern "C++"
// 이 숨어 있다고 보시면 됩니다. 따라서 아래처럼 굳이 명시해줄 필요가 없습니다.
extern "C++" int func2();
int func2();  // 위와 동일

이름 맹글링
C에서 C++의 함수를 사용하기위해서는 extern "C"로 언어링크방식을 명시해줘야한다.
그 이유는 목적파일 생성시 C컴파일러가 함수이름을 변환하는 방식과 c++컴파일러가
함수이름을 변환하는 방식이 다르기 때문.
C의 경우 함수이름 변환 자체가 이뤄지지 않아서
int func(const char* s) {} 를 C컴파일러가 변환하면
$ nm a.out
0000000000000000 T func
c++ 컴파일러가 변환하면
$ nm a.out
0000000000000000 T _Z4funcPKc

함수이름이 변환된 것을 확인.
이것을 Name mangling이라고 하며 엉망진창으로 만들다라는 의미임.
이것은 c++에서는 같은이름의 함수를 정의할 수 있기 때문
오버로딩으로도 가능하고, 다른이름공간이어도 가능

이름 맹글링을하면 함수이름+이름공간+함수의인자 정보가 들어가게됨


링킹
이제야 진짜 링킹 가능.
각각의 TU들에서 생성된 목적코드들을 한데모아 하나의 실행파일을 만드는 작업.
링킹과정이 끝나기 전에는 변수,함수,데이터의 위치를 확정시킬 수 없음.
TU가 생성한 목적 코드들에는 각각 심볼의 저장방식과 링크방식에 따라 배치희망사항만 써져있음
nm 프로그램으로 어떻게 심볼을 배치할지 정보를 볼 수 있다.
$ nm test.o
0000000000000004 D b
0000000000000000 T _Z4funcv
0000000000000000 d _ZL1a
0000000000000000 r _ZL1c
0000000000000000 b _ZL1d
000000000000000b t _ZL5func2v

대문자는 외부링크, 소문자는 내부링크
D, d :초기화된섹션
B, b :초기화가 안된 섹션 BSS
T, t :코드 섹션
R, r :읽기 전용섹션

재배치
목적코드들은 심볼들의 위치가 확정되면 바꿔야할 부분들을 적어놓은 재배치 테이블을 생성해놓음
a: R_X86_64_PC32	.data-0x4
레퍼런스에 따르면 R_X86_64_PC32 은
해당 부분 4 바이트 영역을 S + A - P 를 계산한 값으로 치환해라 라는 의미
S : 재배치 후에 해당 심볼의 실제 위치

P : 재배치 해야하는 부분의 위치

A : 더해지는 값으로, 재배치 테이블에서 그 값을 확인할 수 있다

우선 A는 -4이고  a가 4010에 위치하는 것을 확인 했으니 S가 4010
func2는 1138에 위치하므로 P = 0x1138 + A = 0x1142
S+A-P = 0x4010 - 0x4 - 0x1142 = 0x2ECA

static함수의 경우 내부링크 방식이기때문에 TU밖에서 참조될 일이 없으므로 컴파일타임에
함수 위치를 확정시킬 수 있다.
R_X86_64_PLT32 : 프로시져 링크테이블을 활용한 링크 방식
동적링크방식에서 사용된다. 그러나 동적링크방식을 쓰지않는경우에는 R_X86_64_PC32와 동일함.

정적링킹
정적라이브러리는 링킹 후 완성된 프로그램안에 포함된다.
정적 라이브러리 생성
foo.cc로 생성한 foo.o와 bar.cc로 생성한 bar.o를 묶어 정적 라이브러리를 만든다
ar crf libfoobar.a foo.o bar.o
리눅스에선 통상적으로 정적라이브러리파일은 .a의 확장자를 가집니다.
이 라이브러리를 main.cc에서 사용하고 싶다면
g++ main.cc libfoobar.a -o main 으로 링크해주면 끝임
정적 라이브러리는 링크타임에 바인딩됨.
모든 프로그램이 같은라이브러리를 각각 가지고 있는 건 비효율적이며
라이브러리 하나만 올려두고 프로그램들이 공유해서 쓰는게효율적

공유라이브러리
라이브러리코드를 메모리에 하나만 올려놓는다.
그리고 각각의 프로세스들이 libc가 있는 부분을 참조해 쓰는데 각 프로세스가 부르는 라이브러리의 위치는 다르지만
페이징을 통해 같은 물리메모리 주소에서 가져온다.
공유라이브러리는 섹션의 위치를 특정할 수 없어서 S+A-P를 계산 못하고 PIC (Position Independent Code)를 만들어아한다.
이렇게 하기위해 컴파일 시 -fpic인자를 전달한다.

libfoobar.so 가 생성된 것을 볼 수있다 (shared object)
g++ -c -fpic foo.cc
g++ -c -fpic bar.cc
g++ -shared foo.o bar.o -o libfoobar.so

GOT (Global Offset Table) 실제함수들의 주소값을 이 테이블에 적어놓는다.
bar함수가 GOT에 2번째위치인 GOT[1]에 적혀있다면 call *GOT[1]을 하면 bar함수를 실행할 수 있다.
그런데 처음에는 GOT가 비어있기때문에 
GOT[1]에는 bar의 실제위치를 알아낸후 해당 주소값을 GOT[1]에 덮어씌우는 함수주소가 적혀있게된다.
PLT는 링크타임 시 위치를 알 수 없는 함수들의 위치를 찾아주는 루틴들이 모인 테이블
bar의 GOT상 위치인 1을 스택에 push하고 해당 심볼을 찾는 루틴으로 점프한다(보통 PLT 맨 상단)
해당 루틴에서 Dynamic loader 라이브러리 코드로 점프한다.
이 라이브러리에서 bar함수가 정의 된 곳을 찾게된다.
리눅스의 경우는 ld.so라는 이름의 Dynamic loader를 사용
ld.so는 필요로하는 심볼을 찾아 bar의 실제주소를 GOT[1]에 넣게된다.
어떤 로더를 쓸지는 interlop섹션에 정의되어있다.
dynamic loader 또한 공유라이브러리이다.

마지막으로 bar함수를 호출한다.
두번째 bar호출부터는 GOT[1]에 적어놓은 주소로 바로 점프한다.

이러한 방식을 lazy binding이라고 함.
해당함수를 처음 실행하는 시점에서 많은 시간이 소요됨.

동적링킹방식의 재배치
// foo.cc
#include "bar.h"
int x = 1;

int foo() {
  bar();
  x++;
  return 1;
}

R_X86_64_PLT32 의 경우 재배치 주소 계산 방식이 L + A - P
L은 PLT의 주소값(프로시져 링킹테이블)
전역변수 R_X86_64_REX_GOTPCRELX의 경우는 G + GOT + A - P
G 는 GOT 안에서 해당 심볼 까지의 오프셋
GOT 테이블 자체의 오프셋
변수의 경우에는 해당변수 자체를 GOT내에 위치시키면됨.


